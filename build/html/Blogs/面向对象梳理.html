

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>9. } &mdash; Code-Cookbook 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html" />
    <link rel="prev" title="7. }" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Code-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">大数据</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata%20Tools/index.html">Bigdata Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">博客</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Annotation.html">1. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Collection.html">2. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Collection.html#id14">3. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%20Cookbook.html">4. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">5. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html#id6">6. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">7. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html#id16">8. }</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">9. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id2">10. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id3">11. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">12. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">13. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id6">14. }</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Blogs</a> &raquo;</li>
        
      <li><span class="section-number">9. </span>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Blogs/面向对象梳理.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 面向对象知识点梳理</p>
<p>## 面向对象知识点梳理</p>
<p>### 类</p>
<ul>
<li><p>在java语言中，是使用类进行编写java程序</p></li>
<li><p>~~~java
class 类名{</p>
<blockquote>
<div><p>//书写java代码</p>
</div></blockquote>
</li>
<li><p>在类中可以书写的内容有哪些？</p>
<ul class="simple">
<li><p>变量</p></li>
<li><p>方法</p></li>
</ul>
</li>
<li><p>在java语言中，类除了是用来定义所书写的程序外，类的另一个作用：自定义类型</p></li>
</ul>
<p>### 对象</p>
<ul>
<li><p>当书写完自定义类后，需要对类进行初始化（数据类型  变量=初始化）</p></li>
<li><p>怎么对类进行初始化（初始化的动作，底层：开辟堆内存空间）</p>
<ul>
<li><p>~~~java
类名  对象名 =  new  类名();</p>
<p>类名 ：  数据类型
对象名  ：  变量名
new  ：  告知JVM要开辟堆空间
类名()  ：  告知JVM要开辟空间的大小 （ 类中所书写的所有内容[变量]，进行换算，然后开辟空间 ）</p>
<blockquote>
<div><p>自动调用构造方法</p>
</div></blockquote>
<p>~~~</p>
</li>
<li><p>![avatar](./classInit.png)</p></li>
</ul>
</li>
</ul>
<p>小结 ：
类在程序中可以干什么？</p>
<ul class="simple">
<li><p>java的书写的程序内容都是类为单位
- 类中书写的内容：变量、方法</p></li>
<li><p>java中的类：  数据类型  （JVM基于这个数据类型，开辟堆空间）
- java语言提供的
- 程序员自己定义的（自定义类）</p></li>
</ul>
<p>类中书写的内容，想要使用，怎么办?</p>
<ul class="simple">
<li><p>需要对类进行初始化（JVM在堆中开辟一个空间）</p></li>
<li><p>初始化代码： 类名  对象名 = new  类名()</p></li>
</ul>
<p>### 封装</p>
<ul>
<li><p>在java语言中，在类中书写程序代码（变量、方法）</p>
<ul class="simple">
<li><p>把变量、方法封装到类中</p></li>
</ul>
</li>
<li><p>在java语言中，封装的两种代码体现：</p>
<ul>
<li><p>方法 ， 封装的是一段代码块（所封装的代码块通常是用来解决一个问题的【功能】）</p></li>
<li><p>类 ， 封装的是变量和方法
- 变量，成员变量（实例变量）</p>
<blockquote>
<div><ul class="simple">
<li><p>为什么叫成员？
- 类需要创建对象，而通过“对象.变量”的方式去访问，称为：成员变量</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>方法，成员方法</p></li>
</ul>
</li>
</ul>
</li>
<li><p>~~~java
// 类
class Student{</p>
<blockquote>
<div><p>int age;</p>
</div></blockquote>
<p>}
//在使用Student -&gt; age变量
Student stu = new Student();
stu.age = -10; //赋值为非法数据（影响了程序安全性）
//以上给age赋的值为非法数据</p>
<dl>
<dt>解决方案1：</dt><dd><p>定义一个变量，接收 -10
判断变量是否合法，合法：再赋值给stu.age
int a = -10;
if( a &gt;= 0 ){</p>
<blockquote>
<div><p>stu.age = a;</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>解决方案2： 在Studetn类中</dt><dd><blockquote>
<div><p>第1步：不让外部直接使用age变量 （使用java中的关键字：private ）
第2步：让外部间接把值给到一个方法，在方法中判断值是否合法</p>
<blockquote>
<div><p>合法： 把合法值， 赋值给 age变量</p>
</div></blockquote>
</div></blockquote>
<p>java语言为了保证程序的安全性，提供了一些访问权限： 让程序中的代码使用添加了权限
public
private</p>
<blockquote>
<div><dl>
<dt>class Student{</dt><dd><p>private int age;// 私有的变量（只能在Student类中使用age）</p>
<dl>
<dt>public void setAge(int age){</dt><dd><blockquote>
<div><dl class="simple">
<dt>// age = age;//局部变量 = 局部变量</dt><dd><p>//就近原则：方法中的局部变量会优先使用</p>
</dd>
</dl>
<p>//在java中，区分局部变量和成员变量，使用：this关键字</p>
<dl class="simple">
<dt>if(age&gt;=0){</dt><dd><p>this.age = age;</p>
</dd>
<dt>}else{</dt><dd><p>// 异常
// 日志</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>public int getAge(){</dt><dd><p>return this.age;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>Student stu = new Student();
stu.age = -10; //不能赋值（编译：报错）</p>
<p>//赋值合法数据：
stu.age = 10;// 编译：报错
stu.setAge(10);
stu.setAge(-10);//传递的是一个非法数据</p>
<p>System.out.println(“年龄：”+ stu.getAge() );</p>
</div></blockquote>
</dd>
</dl>
<p>~~~</p>
</li>
</ul>
<p>问题：想要给类中书写变量，进行赋值操作，怎么实现？</p>
<p>~~~java
class Student{</p>
<blockquote>
<div><p>private String name;
private int age;
//新增变量
private String gender;
private String phone;
private String stuId;
private double height;
…..</p>
<dl class="simple">
<dt>public void setName(String name){</dt><dd><p>this.name = name;</p>
</dd>
</dl>
<p>}
。。。。</p>
</div></blockquote>
<p>}
//对类进行初始化
Student stu = new Student();
stu.setName(“测试”);
stu.setAge(10);</p>
<p>//当类中书写的成员变量过多时，需要使用大量的setXxx()方法，给类中的变量赋值</p>
<p>另一个斛决方案： java中的构造方法
~~~</p>
<p>### 构造方法</p>
<p>什么是构造方法？</p>
<p>1、和类名相同</p>
<p>2、没有返回值类型（不需要书写void关键字）</p>
<p>~~~java
class Student{</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>private String name;
private int age;
private String gender;
private String phone;</p>
</div></blockquote>
<dl>
<dt>//构造方法</dt><dd><p>public Student(){ //空参构造方法</p>
<p>}</p>
<dl>
<dt>public Student(String name,int age,…){</dt><dd><p>//考虑到非法数据问题
if( age &gt;= 0 ) {</p>
<blockquote>
<div><p>this.age = age;</p>
</div></blockquote>
<p>}else{</p>
<p>}</p>
<blockquote>
<div><p>this.name=name;
…</p>
</div></blockquote>
<dl class="simple">
<dt>//开发中有不少这样写：</dt><dd><p>this.setAge(age);
this.setPhone(phone);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>//给私有的age变量赋值
public void setAge(int age){</p>
<blockquote>
<div><dl class="simple">
<dt>if(age&gt;=0){</dt><dd><p>this.age = age;</p>
</dd>
<dt>}else{</dt><dd><p>// 异常
// 日志</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>构造方法对于书写程序的作用： 可以对类中的私有成员变量进行赋值</p>
<p>1、当类中有私有成员时，对类中的私有成员进行赋值操作：setXxx()
2、当类中有私有成员时，使用类的有参构造方法，对类中的私有成员进行赋值操作</p>
<blockquote>
<div><p>私有成员变量，只有在本类中使用（构造方法也属于本类）</p>
</div></blockquote>
<p>~~~</p>
<p>小结：</p>
<p>针对类中的私有成员变量，有两种赋值方式：</p>
<p>1、public void setXxx(数据类型 参数)</p>
<p>2、类中的有参构造方法</p>
<p>&gt; 注意：构造方法不是由书写的程序调用的，而是由JVM自动调用
&gt;
&gt; 什么时候调用构造方法？
&gt;
&gt; 在对类进行初始化操作时： 类名  对象名 = new 类名(); //在执行当前行代码时，自动调用构造方法</p>
<p>类：自定义类型（数据类型）</p>
<p>对象：对类进行初始化。 只有类初始化后，才可以访问类中的成员变量、成员方法</p>
<p>当变量、方法书写在类中时，就相当于把变量和方法进行了封装</p>
<p>为了程序中数据的安全性考虑，建议：把成员变量私有化</p>
<p>私有化的成员变量带来一个问题：外部程序无法访问</p>
<p>解决方案1： 提供相应的getter（获取私有成员变量的值）、setter（对私有成员变量赋值）</p>
<p>解决方案2： 使用类中的有参构造方法 （对私有成员变量赋值）</p>
<p>### 继承</p>
<p>~~~java
学生管理系统： 学生、老师
类：老师类
类：学生类
//学生类
class Student(){</p>
<blockquote>
<div><p>private String name;
private int stuId;
private int age;</p>
<dl class="simple">
<dt>public void study(){</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
//老师类
class Teacher{</p>
<blockquote>
<div><p>private String name;
private int teaId;
private int age;</p>
<dl class="simple">
<dt>public void teach(){</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
通过观察，Teacher类和Student类，中有不少相同的代码。
需求1：在Teacher类和Studetn类中，新增属性：教室
//学生类
class Student(){</p>
<blockquote>
<div><p>private String name;
private int stuId;
private int age;</p>
<p>//新增
private String classRoom;</p>
<dl class="simple">
<dt>public void study(){</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
//老师类
class Teacher{</p>
<blockquote>
<div><p>private String name;
private int teaId;
private int age;</p>
<p>//新增
private String classRoom;</p>
<dl class="simple">
<dt>public void teach(){</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
需求2：系统升级了，  原的学生学号和老师学号，int类型存储不下了，需要扩展类型： long 或 String
再对Student类和Teacher类进行改造</p>
<p>通过刚才两个需求，发现：每次都要修改多个类中的代码（程序的修改过多）
有没有简单一些方案呢？
答： 继承
~~~</p>
<p>&gt; 要实现继承需要什么?
&gt;
&gt; 1、要定义一个父类
&gt;
&gt; 2、要定义一个子类，子类要继承父类
&gt;
&gt; ​     继承的关键字： extends</p>
<p>~~~java
//定义一个父类
class Person{</p>
<blockquote>
<div><p>private String name;
private int teaId;
private int age;
…</p>
</div></blockquote>
<p>}
//定义一个子类
class Student extends Person{</p>
<blockquote>
<div><dl class="simple">
<dt>public void study(){</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
//定义一个子类
class Teacher extends Person{</p>
<blockquote>
<div><dl class="simple">
<dt>public void teach(){</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>继承的特点：
1、子类在继承父类后，可以直接使用父类中的非私有成员方法、成员变量</p>
<p>需求1：在Teacher类和Studetn类中，新增属性：教室
解决方案：只需要在Person类中，添加：教室   （只修改一处代码）
class Person{</p>
<blockquote>
<div><p>private String name;
private int teaId;
private int age;
…</p>
<p>//新增
private String classRoom;</p>
</div></blockquote>
<p>}</p>
<p>需求2：系统升级了，  原的学生学号和老师学号，int类型存储不下了，需要扩展类型： long 或 String
解决方案：只需要修改Person类中的代码。 int    -&gt;&lt;  long   （只修改一个类中的代码）
class Person{</p>
<blockquote>
<div><p>private String name;
private long teaId;
private int age;
…</p>
<p>//新增
private String classRoom;</p>
</div></blockquote>
<div class="section" id="id1">
<h1><span class="section-number">9. </span>}<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<p>继承的特点：
1、子类在继承父类后，可以直接使用父类中的非私有成员方法、成员变量</p>
<p>2、子类只能继承一个父类（单一继承）</p>
<p>3、子类继承一个父类，父类再继承一个爷爷类，爷爷类再继承… (多层次继承 )</p>
<ul class="simple">
<li><p>子类除了可以使用父类中的非私有成员外，还可以使用爷爷类中的非私有成员</p></li>
</ul>
<p>继承的好处：提供程序中代码的复用性</p>
<p>&gt; 继承中构造方法的原理：
&gt;
&gt; 子类在初始化对象时，为了确保子类可以正常访问父类中的成员，需要先对父类进行初始化
&gt;
&gt; 子类的构造方法中，会先调用父类的构造方法
&gt;
&gt; 示例：
&gt;
&gt; class Person{
&gt;
&gt;    public Person(){
&gt;
&gt;    }
&gt;
&gt; }
&gt;
&gt; class Student extends Person{
&gt;
&gt;    public Student(){
&gt;
&gt; ​        //第一行代码： super()  //调用父类中的空参构造方法  （JVM自动添加）
&gt;
&gt;    }
&gt;
&gt; }
&gt;
&gt;
&gt;
&gt; 【注意】：当父类中的没有空参构造方法时，子类的构造方法中必须书写：super(参数)
&gt;
&gt;</p>
<p>###  this和super</p>
<p>this ： 代表当前对象</p>
<p>super： 代表父类对象</p>
<p>使用方式：</p>
<p>~~~java
//成员变量
this.name;//访问本类中的成员变量
super.name;//访问父类中的成员方法</p>
<p>//成员方法
this.method();//访问本类中的成员方法
super.method();//访问父类中的成员方法</p>
<p>//构造方法
this();   this(参数);  //访问本类中的构造方法
super();   super(参数); //访问父类中的构造方法
~~~</p>
<p>### 多态</p>
<p>~~~java
//父类
abstract class Person{</p>
<blockquote>
<div><p>private String name;
private int age;</p>
<p>//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
//抽象方法： 只定义没有方法体
public abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class Student extends Person{</dt><dd><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校区食堂吃饭…”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
class Teacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校外吃饭…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<blockquote>
<div><dl>
<dt>class Test{</dt><dd><dl>
<dt>public static void main(String[] args){</dt><dd><p>//创建学生对象
Student stu = new Student();</p>
<p>method1( stu  , “zs” , 20  ,   …..)</p>
<p>//创建老师对象
Teacher tea = new Teacher();</p>
<p>method2(  tea ,”ls” ,33 , …… )</p>
</dd>
</dl>
<p>}</p>
<p>//大在书写程序时：当发现有重复的代码，建议都进行抽取封装：方法、类  （复用性）</p>
<blockquote>
<div><dl class="simple">
<dt>public static void method1( Student stu, String name , int age , … ){</dt><dd><p>stu.setName( name  );//因为Student继承了Person，可以使用父类中的非私有成员
stu.setAge(  age  );
….
stu.eat();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public static void metho2 ( Teacher  tea , String name , int age , …  ){</dt><dd><p>tea.setName(  name   );
tea.setAge(  age  );
….
tea.eat();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>//添加就业班</p>
<p>//观察以上两个方法中的代码：除了对象名不同，其它都一样   (99%都是重复代码)
针对代码，再次精进：</p>
<blockquote>
<div><p>public void method(  ?   , String name , int age , …){</p>
<blockquote>
<div><p>?.setName(  name   );
?.setAge(  age  );</p>
<p>?.eat();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>? 有两个类型：  Student 、        Teacher
Student类型和Teacher类型有什么相同？
继承的父类是同一个</p>
<p>java语言提供了一种方案：多态
多态的使用:
1、要有继承关系
2、子类要重写父类中的方法
3、 父类的引用指向子类对象</p>
<blockquote>
<div><p>父类  父引用  =  new  子类();</p>
</div></blockquote>
<p>Person p1 = new Student();
p1.setName(…)
p1.eat()//调用的是对象中的eat方法</p>
<p>Person p2 = new Teacher();
p2.setName(….)
p2.eat();</p>
<blockquote>
<div><p>public static void method(  Person p  ,  String name , int age , …  ){</p>
<blockquote>
<div><p>p.setName(  name   );
p.setAge(  age  );</p>
<p>p.eat();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>Student stu = new Student();
Person p = stu ; //多态</p>
<p>method( stu ,”ls” , 20 ,….);</p>
<dl class="simple">
<dt>Teacher tea = new Teacher();</dt><dd><p>method( tea   );</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>~~~</p>
<p>![avatar](./multiState.png)</p>
<p>~~~java
//父类
abstract class Person{</p>
<blockquote>
<div><p>private String name;
private int age;</p>
<p>//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
//抽象方法： 只定义没有方法体
public abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class Student extends Person{</dt><dd><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校区食堂吃饭…”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
class Teacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校外吃饭…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>//需求升学：老师需要划分为基础班老师、就业班老师
//父类
abstract class Person{</p>
<blockquote>
<div><p>private String name;
private int age;</p>
<p>//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
//抽象方法： 只定义没有方法体
public abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class Student extends Person{</dt><dd><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校区食堂吃饭…”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//基础班老师
class BasicTeacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“吃外卖…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
//就业班老师
class WorkTeacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校外吃饭…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<blockquote>
<div><dl>
<dt>class Test{</dt><dd><dl>
<dt>public static void main(String[] args){</dt><dd><p>//创建学生对象
Student stu = new Student();</p>
<p>//创建基础老师对象
BasicTeacher tea = new BasicTeacher();</p>
<p>//创建就业班老师对象
WorkTeacher tea2 = new WorkTeacher();</p>
<p>method(  stu , “zs” , 20  )
method(  tea , “ls” , 33  )</p>
<p>method(  tea2  , “ja”  30  )</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public static void method(  Person  p ,  String name, int age ){</dt><dd><blockquote>
<div><p>p.setName( name )
p.setAge(age)
…</p>
<p>p.eat();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>~~~</p>
<p>&gt; 在使用多态时，存在 一个问题：父引用无法使用子类中特有的成员
&gt;
&gt; 解决方案： 使用向下转型 （强制类型转换）
&gt;
&gt; 格式：子类  子类对象 = (子类) 父引用
&gt;
&gt;
&gt;
&gt; 当在进行强制类型转换时，如果父引用指向的对象类型 和 要转换的类型不匹配，就会发生：错误
&gt;
&gt; 父引用指向的对象类型 ：  Person p = new Student();  //类型：Student
&gt;
&gt; 要转换的类型：  Teacher
&gt;
&gt; 错误代码：  Teacher tea  = (Teacher ) p;//类型转换错误
&gt;
&gt;
&gt;
&gt; 通常在进行向下转型时，会先进行判断：
&gt;
&gt; if( p  instanceo  Teacher){
&gt;
&gt;   Teacher tea  = (Teacher ) p;
&gt;
&gt; }
&gt;
&gt; 父引用  instanceof  子类类型    ：  判断父引用指向的对象类型 是否为 子类类型</p>
<p>抽象类</p>
<ul>
<li><p>为什么有抽象类？</p>
<ul class="simple">
<li><p>当程序中书写的方法只有声明，没有方法体代码实现，该需要修饰为：abstract</p></li>
<li><p>抽象方法必须存在于抽象类中</p></li>
</ul>
</li>
<li><p>~~~java
abstract class Person{</p>
<blockquote>
<div><p>//抽象方法
public abstract void eat();</p>
</div></blockquote>
</li>
<li><p>抽象类的特点：</p>
<ul class="simple">
<li><p>不能实例化（ 不能创建对象。 只能通过子类来创建对象[多态的方式] ）</p></li>
<li><p>抽象类和普通类，除了不能实例化、多了一个抽象方法外，其他和普通类都一样
- 抽象类中可以书写的内容：抽象方法、构造方法、成员变量、成员方法
- 抽象类中的构造方法的作用：为了保证子类对象创建成功</p></li>
<li><p>抽象类通常都是父类</p></li>
<li><p>抽象类中的抽象方法，子类必须重写</p></li>
</ul>
</li>
</ul>
<p>### 接口</p>
<p>~~~java
接口比类好的地方：可以多实现</p>
<p>接口在java中怎么使用：
1、定义一个接口
2、定义一个子类，子类实现接口，子类中并重写接口中的抽象方法
3、接口要创建对象，只使用多态的形式：  接口  父引用 = new  子类()</p>
<p>//定义接口
interface InterA{</p>
<blockquote>
<div><p>//接口中可书写内容是固定的
常量、抽象方法、静态方法、默认方法</p>
<p>public static final int NUM=10;//常量
public abstract void method();//抽象方法
public static void method2(){</p>
<p>}
public default void method3{</p>
<p>}</p>
</div></blockquote>
<p>}
//定义实现接口的类
class MyInter implements InterA{</p>
<blockquote>
<div><p>//重写抽象方法</p>
</div></blockquote>
<p>}
//使用接口：
InterA inter = new MyInter();
~~~</p>
<p>~~~java
abstract classs Person{</p>
<blockquote>
<div><blockquote>
<div><p>String name;
int age ;</p>
</div></blockquote>
<p>abstract  void eat();</p>
</div></blockquote>
<p>}
class BasicStudent extends Person{</p>
<blockquote>
<div><p>public void study(){</p>
<p>}</p>
</div></blockquote>
<p>}
class WorkStudent extends Person implements InterA{</p>
<blockquote>
<div><p>public void study(){</p>
<p>}
//特有的功能
public void mianshi(){</p>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class BasicTeacher extends Person{</dt><dd><p>public void teach(){</p>
<p>}</p>
</dd>
</dl>
<p>}
class WorkerTeacher extends Person implements InterA{</p>
<blockquote>
<div><blockquote>
<div><p>public void teach(){</p>
</div></blockquote>
<dl class="simple">
<dt>}</dt><dd><p>//特有的功能</p>
</dd>
</dl>
<p>public void mianshi(){</p>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>interface InterA{</dt><dd><p>public void mianshi();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>需求：学生都有学习方法、老师都讲课方法</dt><dd><p>就业班学生、就业班老师都具有：面试能力</p>
</dd>
</dl>
<p>BasicStudent bs = new BasicStudent();
WorkTeacher tea = new WorkTeacher();</p>
<dl class="simple">
<dt>接口：</dt><dd><p>1、当有部分类中的功能是相同时，可以把这部分相同的功能，抽取出来，封装到：接口</p>
</dd>
</dl>
<p>要执行就业班老师和就业班学生的：面试功能
WorkTeacher tea = new WorkTeacher();
WorkStudenet stu = new WorkStudent();
tea.mianshi();
stu.mianshi();</p>
<p>method( tea );
method(  stu )</p>
<dl class="simple">
<dt>public void method( InterA inter ){</dt><dd><p>inter.mianshi()</p>
</dd>
</dl>
</div>
<div class="section" id="id2">
<h1><span class="section-number">10. </span>}<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h1>
<p>在企业开发中，大量使用接口。</p>
<p>&gt; 为什么？
&gt;
&gt; 通常在开发前期，会针对开发中的功能进行制定（需求分析）
&gt;
&gt; 前期：制定功能（没有功能代码）
&gt;
&gt; ​           使用抽象方法
&gt;
&gt; 问题：抽象方法是定义哪里？  抽象类  or 接口？
&gt;
&gt; 答案： 接口  （接口可以多实现）
&gt;
&gt;
&gt;
&gt; 程序开发：接口
&gt;
&gt; public interface 接口A｛
&gt;
&gt;    //功能1：
&gt;
&gt; ​                public  boolean  login(String name,Strng passwd);
&gt;
&gt;   //功能2：
&gt;
&gt; ​                 public  boolean  changePasswd(String name , String oldPasswd);
&gt;
&gt; }
&gt;
&gt; public interface 接口B｛
&gt;
&gt;   …..
&gt;
&gt; ｝</p>
<p>进入到开发阶段：</p>
<p>~~~java
//程序员01号
class UserImpl implements IUser｛</p>
<blockquote>
<div><dl class="simple">
<dt>//重写抽象方法</dt><dd><p>具体方法中的功能代码</p>
</dd>
</dl>
</div></blockquote>
<p>｝
class OrderImpl implements  IOrder{</p>
<p>}
class ManagerImpl  implements IManager{</p>
<p>}</p>
<hr class="docutils" />
<p>//程序员02号
class 类{</p>
<blockquote>
<div><p>public void method(){</p>
<blockquote>
<div><p>//让用户先登录
IUser user = new UserImpl();//多态  接口
user.login(“”,””)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div>
<div class="section" id="id3">
<h1><span class="section-number">11. </span>}<a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h1>
<p>## 面向对象</p>
<p>### 包</p>
<p>在学习java基础时，使用过Scanner。 要使用Scanner需要导入：import java.util.Scanner</p>
<p>包是什么？</p>
<ul class="simple">
<li><p>文件夹
- 可以帮我们管理文件</p></li>
</ul>
<p>包能做什么？</p>
<ul class="simple">
<li><p>在开发中，程序员会书写很多的类，这些类有一些可能会出现重名</p></li>
<li><p>在开发中，所开发的项目中，会包含不同功能模块：商品、订单、用户、….
- 针对不同的功能模块，书写不同的java程序</p></li>
<li><p>包的作用：可以帮我们管理.java文件
- 避免重名
- 实现不同功能的类，可以存放在不同的功能模块下</p></li>
</ul>
<p>怎么使用包？</p>
<p>~~~java
创建包：package</p>
<blockquote>
<div><p>把不现的.java文件存放在不同的包下</p>
</div></blockquote>
<dl class="simple">
<dt>导入包：import</dt><dd><p>当需要使用别人开发好的功能时，需要先找到功能所属的类，然后使用import导入这个类
创建类对象，使用对象.功能()</p>
</dd>
</dl>
<p>~~~</p>
<p>package使用注意事项：</p>
<p>1、package必须书写在java程序的首行</p>
<p>2、一个.java文件夹中，只能书写 一个package</p>
<p>~~~ java
package com.itheima;  //只能有一个package
//package com.itcast;//报错</p>
<p>class Itcast{</p>
</div>
<div class="section" id="id4">
<h1><span class="section-number">12. </span>}<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h1>
<p>包的命名规则：</p>
<p>1、全部小写字母</p>
<p>2、包名通常使用域名，倒着写的方式（企业中的标准）</p>
<p>3、通常创建包名，都是有多个包，包之间使用.连接</p>
<ul class="simple">
<li><p>~~~java
package com.itheima.hw.demo1;
~~~</p></li>
</ul>
<p>在书写程序时，需要引用别人写好的类中功能，需要：导包</p>
<p>~~~java
package com.itheima;// Test类归属的包</p>
<p>import java.util.Scanner;//导包</p>
<dl class="simple">
<dt>class Test{</dt><dd><p>Scanner sc = new Scanner(System.in);///要使用别人写的功能，要导入</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h1><span class="section-number">13. </span>}<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h1>
<p>在书写 程序时，有两种导入包的方式：</p>
<p>~~~java
第一种：(不推荐)</p>
<blockquote>
<div><p>java.util.Scanner  sc = new java.util.Scanner(System.in);//书写类名时直接把包导入</p>
<p>java.util.Scanner  sc2 = new java.util.Scanner(System.in);</p>
<p>java.util.Scanner  sc3 = new java.util.Scanner(System.in);</p>
</div></blockquote>
<dl>
<dt>第二种：</dt><dd><p>import java.util.Scanner;</p>
<p>Scanner sc = new Scanner(System.in);</p>
<p>Scanner sc2 = new Scanner(System.in);</p>
<p>Scanner sc3 = new Scanner(System.in);</p>
</dd>
</dl>
<p>~~~</p>
<p>### 访问修饰符</p>
<p>在java中为了程序的安全性，java语言提供了4种用来访问成员的权限</p>
<p>1、public</p>
<ul>
<li><p>~~~ java
public class Student{</p>
<blockquote>
<div><p>//公开的
public void study(){</p>
<p>}</p>
</div></blockquote>
</li>
</ul>
<p>2、private</p>
<ul>
<li><p>~~~ java
public class Student{</p>
<blockquote>
<div><p>private String name;//私有的。只能本类使用</p>
</div></blockquote>
</li>
</ul>
<p>3、默认       什么都不书写</p>
<ul>
<li><p>~~~java
public class Student{</p>
<blockquote>
<div><p>String name;//默认的访问修饰符</p>
</div></blockquote>
</li>
</ul>
<p>4、protected</p>
<ul>
<li><p>~~~java
pubilc class Student extends Person{</p>
<blockquote>
<div><p>protected String name;//受保护的（子类专用）</p>
</div></blockquote>
<p>&gt; <strong>访问修饰符号的访问范围</strong></p>
<div class="line-block">
<div class="line">修饰符号 (从小到大排列) | 本类    | 同一个包下的类(非子类) | 同一个包下的子类 | 不同包下的类（非子类） | 不同包下的子类 |</div>
<div class="line">———————– | ——- | ———————- | —————- | ———————- | ————– |</div>
<div class="line">private                 | <strong>YES</strong> | NO                     | NO               | NO                     | NO             |</div>
<div class="line">默认                    | <strong>YES</strong> | <strong>YES</strong>                | <strong>YES</strong>          | NO                     | NO             |</div>
<div class="line">protected               | <strong>YES</strong> | NO                     | <strong>YES</strong>          | NO                     | <strong>YES</strong>        |</div>
<div class="line">public                  | <strong>YES</strong> | <strong>YES</strong>                | <strong>YES</strong>          | <strong>YES</strong>                | <strong>YES</strong>        |</div>
</div>
</li>
</ul>
<p>## 常用API</p>
<p>### Object类</p>
<p>Object类的基本认知：</p>
<p>1、java.lang.Object</p>
<p>2、Obejct类是java语言中的鼻祖类（最顶层的父类）</p>
<p>3、java中程序中所书写的类以及所使用的类，都要继承Object</p>
<ul>
<li><p>~~~java
//父类
class Father{//书写时没有书写继承 JVM自动会添加：class Father extends Object</p>
<p>}
//子类
class Child extends Father{</p>
</li>
<li><p>可以使用Object类中的成员方法(功能)</p></li>
</ul>
<p>Object类中的成员方法 ：</p>
<ul>
<li><p>String   toString()</p>
<ul class="simple">
<li><p>功能：返回字符串格式的对象</p></li>
</ul>
</li>
<li><p>boolean  equals(Object  obj)</p>
<ul>
<li><p>~~~ java
Student stu = new Student();</p>
<p>equals(  stu  )   //   Object obj = stu;
~~~</p>
</li>
<li><p>功能：比较两个对象是否相等</p></li>
</ul>
</li>
</ul>
<p>### String类</p>
<p>之前一直在使用：</p>
<p>~~~java
class Student{</p>
<blockquote>
<div><p>private String name;</p>
</div></blockquote>
</div>
<div class="section" id="id6">
<h1><span class="section-number">14. </span>}<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h1>
<p>String到底是什么 东西？ 它是一种数据类型呢？还是一个类呢？</p>
<p>String是一个类。不属于java的基本数据类型，属于引用类型</p>
<p>在java语言中，只要书写了`”….”<a href="#id7"><span class="problematic" id="id8">`</span></a>,默认就是一个字符串对象：String类的对象</p>
<p>简单理解：在java中只要被英文的双引号包含的内容，默认就是一个String对象</p>
<p>String类的特点：</p>
<p>1、被英文双引号包含的内容，都是一个String类的实例</p>
<p>2、String中存储的字符串，不能被修改（不能对原值进行修改）</p>
<p>String类中的常用方法 ：</p>
<ul>
<li><p>boolean  equals(Object obj)  :     String类重写了Object类中equals方法。
-  String类中的equals方法 ，功能：  比较两个字符串的内容是否相等，区分大小字母
- 在java语言中：</p>
<blockquote>
<div><ul class="simple">
<li><p>比较字符串的地址，使用 ： ==</p></li>
<li><p>比较字符串内容，使用： equals() 方法</p></li>
</ul>
</div></blockquote>
</li>
<li><p>boolean  equalsIgnoreCase(String  str)  ：   比较两个字符串是否相等，忽略大小写</p></li>
</ul>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%84%E7%A7%8D%E5%85%B3%E7%B3%BB.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html" class="btn btn-neutral float-left" title="7. }" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020-2020, roohom

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>