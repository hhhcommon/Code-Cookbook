

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>4. } &mdash; Code-Cookbook 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="Java_Maven.html" />
    <link rel="prev" title="&lt;no title&gt;" href="IO%E6%B5%81.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Code-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">大数据</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata%20Tools/index.html">Bigdata Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">博客</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Annotation.html">1. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Collection.html">2. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Collection.html#id14">3. }</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">4. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">5. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html#id6">6. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">7. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html#id16">8. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html">9. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id2">10. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id3">11. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id4">12. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id5">13. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id6">14. }</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Blogs</a> &raquo;</li>
        
      <li><span class="section-number">4. </span>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Blogs/Java Cookbook.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># JAVA Cookbook</p>
<p>[TOC]</p>
<p>### IDEA 常用快捷键
&gt; Alt+shift+上下方向键 移动当前代码行（选中的代码块）
&gt; ctrl+N 当前项目中的文件过多时，方便快速查找定位文件
&gt; ctrl+D 复制光标所在行（选中的代码块）
&gt; ctrl+Y 删除光标所在行（选中的代码块）
&gt; Ctrl+ALT+L 针对当前的代码进行代码格式化
&gt; ALT+Enter 在IDEA中当书写程序时，遇到红色提示时可以使用该快捷键来解决该提示问题</p>
<p>### 常量
- 字符常量</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>字符和字符串</dt><dd><ul>
<li><p>字符使用单引号，如 ‘A’</p></li>
<li><p>字符串使用双引号，如”ABC”</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>字符串常量</p></li>
<li><dl class="simple">
<dt>布尔常量</dt><dd><ul>
<li><p>True or False</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>空常量</dt><dd><ul>
<li><p>null</p></li>
<li><p>不能通过输出语句直接打印</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 变量
在程序运行过程中可以改变的量
变量的定义格式: 数据类型 变量名=变量值 如 int a=10；</p>
<p>### 数据类型
Java是一门**强类型**语言：在定义变量时就指定了变量的具体类型，在程序运行过程中无法对变量的类型进行修改
弱类型:Scala语言
- 基本数据类型</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>整数</dt><dd><ul>
<li><p>byte     一个字节，取值范围:-128~127</p></li>
<li><p>short   两个字节， 15次方</p></li>
<li><p>默认 int   四个字节，31次方</p></li>
<li><dl class="simple">
<dt>long    八个字节</dt><dd><ul>
<li><p>为了区分，在值末尾加上L</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>小数</dt><dd><ul>
<li><p>float 四个字节，单精度浮点数 默认六到八位</p></li>
<li><p>默认 double 八个字节，双精度浮点数</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>字符</dt><dd><ul>
<li><p>char 两个字节， 英文单引号包含的单个字符</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>布尔Boolean 一个字节</dt><dd><ul>
<li><p>True</p></li>
<li><p>False</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>![avatar](./charTypes.png)</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>引用数据类型</dt><dd><ul>
<li><p>类</p></li>
<li><p>接口</p></li>
<li><p>数组[]</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>标识符</p></li>
</ul>
<p>给程序中变量、类、方法、数组等起的名字
要求(命名规则):</p>
<blockquote>
<div><ul class="simple">
<li><p>标识符只能由:大小字母、数字、下划线、$组成</p></li>
<li><p>必须是以：英文字母或下划线或$开头（不能是数字开头）</p></li>
<li><p>不能是Java中的关键字</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>命名规范:</dt><dd><ul>
<li><p>类名、接口的命名规范:大驼峰命名法</p></li>
<li><p>变量、方法的命名规范:小驼峰命名法</p></li>
<li><p>包的命名全部都以小写字母为主，通常名称是使用域名倒着写</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 类型转换
- 自动类型转换(隐式类型转换)</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>原则:小类型转换为大类型</dt><dd><p>byte -&gt; short int long float double
short -&gt; int  long float double
int -&gt; long float double
float -&gt; double
char -&gt; int -&gt; long</p>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>强制类型转换(显示类型转换)</dt><dd><ul class="simple">
<li><p>原则: 在程序中，把大类型转换为小类型，不能自动转换，需要手动强制进行转换</p></li>
</ul>
<p>格式: 小类型名 变量=(小类型名) 大类型的运算结果</p>
</dd>
</dl>
</li>
</ul>
<p>### 运算符
- 在Java中任何数据类型和字符串相加，”+”的作用都变成了拼接，其结果都是拼接字符串</p>
<blockquote>
<div><ul class="simple">
<li><p>例:S.o.p(“5+5”+5+5); 输出是5+5=55</p></li>
<li><p>而S.o.p(“5+5”+(5+5));结果才是5+5=10</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>在Java中一元运算的优先级高于二元运算</dt><dd><ul>
<li><dl class="simple">
<dt>一元运算</dt><dd><ul>
<li><dl class="simple">
<dt>自增</dt><dd><ul>
<li><p>只能用于变量</p></li>
<li><p>b = a++ 先赋值,再参与运算</p></li>
<li><p>b = ++a 先参与运算，再赋值</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>自减</dt><dd><ul>
<li><p>道理同自增</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>a += 1之类的计算结果等同于  a = a+1</p></li>
<li><dl class="simple">
<dt>但是内部机制并不是如此:</dt><dd><p>short s=1;
s += 10;
其实等价于
short s=1;
s = (short) (s+10);</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>二元运算</dt><dd><ul>
<li><p>加、减、乘、除、取余</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>逻辑运算符</p></li>
</ul>
<dl class="simple">
<dt>只能针对Boolean进行运算</dt><dd><ul class="simple">
<li><dl class="simple">
<dt><a href="#id1"><span class="problematic" id="id2">**</span></a>短路与**&amp;&amp;</dt><dd><ul>
<li><p>作用：等同于逻辑与(&amp;)</p></li>
<li><dl class="simple">
<dt>特殊之处:</dt><dd><ul>
<li><p>当&amp;&amp;之前的运算结果为false时，其后面的运算不会再执行(在与操作中已经得到了一个否，则结果必为否)。</p></li>
<li><p>执行速度更快</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><a href="#id3"><span class="problematic" id="id4">**</span></a>短路或**||</dt><dd><ul>
<li><p>作用:等同于逻辑或(|)</p></li>
<li><dl class="simple">
<dt>特殊之处:</dt><dd><ul>
<li><p>当||之前的结果为false时，其后面的表达式便不会再执行</p></li>
<li><p>速度更快</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<ul class="simple">
<li><p>三元运算符</p></li>
</ul>
<p>格式:
数据类型 变量名 = (关系表达式) ? 表达式1:表达式2
&gt; 变量接收的是表达式1的运算结果或者是表达式2的运算结果
&gt; 如果关系表达式为true，则执行表达式1
&gt; 如果关系表达式为false，则执行表达式2</p>
<ul class="simple">
<li><p>键盘录入</p></li>
</ul>
<dl class="simple">
<dt>试用步骤:</dt><dd><ul class="simple">
<li><p>1.导入Scanner包 import java.util.Scanner;</p></li>
<li><p>2.创建Scanner对象,Scanner sc = new Scanner(System.in);</p></li>
<li><dl class="simple">
<dt>3.获取键盘录入的数据:</dt><dd><p>如:String str = sc.next();
如:int num = sc.nextInt();</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
<p>### 分支结构
- switch语句</p>
<blockquote>
<div><ul>
<li><p>当判断的条件不是进行区间比较时，仅只是进行两个数据之间相等的比较时</p></li>
<li><p>switch之后的括号里可以接收变量、常量和表达式需要确保其类型必须是byte、short、int、char、String或枚举</p></li>
<li><p>default可以书写在任何位置，但除了末尾的位置都必须写break</p></li>
<li><p>case穿透现象</p></li>
<li><dl>
<dt><strong>假设表达式的值 = 值1, 则执行完语句体1后, 不会判断第二个case, 直接执行语句体2</strong></dt><dd><p>~~~java
witch(表达式){</p>
<blockquote>
<div><dl>
<dt>case 值1:</dt><dd><p>语句体1;   //假设表达式的值 = 值1, 则执行完语句体1后, 不会判断第二个case, 直接执行语句体2;</p>
</dd>
<dt>case 值2:</dt><dd><p>语句体2;
break;</p>
</dd>
<dt>case 值3:</dt><dd><p>语句体3;
break;</p>
<blockquote>
<div><p>…    //根据需求, 可以写多组case.</p>
</div></blockquote>
</dd>
<dt>default:</dt><dd><p>语句体n;
break;</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</li>
<li><p>案例 SwitchPenetrate.java</p></li>
</ul>
</div></blockquote>
<p>### 循环
- 三种循环</p>
<blockquote>
<div><ul>
<li><dl>
<dt>for循环</dt><dd><ul>
<li><dl class="simple">
<dt>流程</dt><dd><ul class="simple">
<li><p>1.执行循环初始值</p></li>
<li><p>2.判断循环条件是否满足</p></li>
<li><p>3.执行for循环体重的代码</p></li>
<li><p>4.修改循环条件中的值</p></li>
<li><p>重复2、3、4</p></li>
<li><p>直到不满足循环条件</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>特点:</p>
<blockquote>
<div><ul class="simple">
<li><p>先判断，再执行循环体</p></li>
</ul>
</div></blockquote>
</li>
<li><dl>
<dt>句式语法</dt><dd><ul>
<li><p>~~~java
for(循环初始值;循环条件;循环条件中值的修改)
{</p>
<blockquote>
<div><p>code block;</p>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>while循环</p></li>
<li><p>do…while循环</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>循环三要素</dt><dd><ul>
<li><p>循环初始值</p></li>
<li><p>循环条件</p></li>
<li><p>循环条件中值的修改(修改循环条件)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>循环差异</dt><dd><ul>
<li><p>在for循环执行完之后，无法使用for循环里的初始化条件，比如循环执行过程中自动改变的变量</p></li>
<li><p>而在while循环执行完之后，他的循环条件却还可以使用</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 随机数
在java中提供的一个获取[0.0~1.0)之间的随机数字的包Random
~~~java
1.导入包（省去）
2.创建对象
3.使用获取随机数的功能
~~~
- 使用</p>
<blockquote>
<div><ul class="simple">
<li><p>格式</p></li>
</ul>
<p>Math.random()
~~~java
int num = (int)(Math.random()*100+1); //生成一个1-100之间的随机整数
~~~</p>
</div></blockquote>
<ul class="simple">
<li><p>在java中如果使用Math.random()生成随机数</p></li>
</ul>
<p>如果是要生成[10,100]的随机数， (int)(Math.random()*91+10)
提取其中的(<strong>公式</strong>) :将Math.random()用MR代替。
如果是要求[a,b]范围，则是MR*((b-a)+1)+a
如果是[a,b)范围，则是MR*(b-a)+a</p>
<p>### 数组
定义的方式:
举例:
- 动态初始化</p>
<blockquote>
<div><ul class="simple">
<li><p>int array[] = new int[5]</p></li>
<li><p>int[] array = new int[5]</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>静态初始化</dt><dd><ul>
<li><p>int[] array = new int[]{1,2,3,4,5}</p></li>
<li><p>int array[] = {1,2,3,4,5}</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>数组的遍历可以使用for循环，同时java也提供了一个方法来直接打印数组 -&gt; Arrays.toString(arr)</p></li>
</ul>
<p>打印的结果形式是[元素,元素,…]
### <strong>Java程序的内存划分</strong>
- 栈</p>
<blockquote>
<div><ul class="simple">
<li><p>作用:存储局部变量，程序要运行的代码，局部变量就是定义在方法中的变量，栈中存放的就是方法</p></li>
<li><p>特点:先进后出(FILO)</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>堆</dt><dd><ul>
<li><p>作用:存储使用new关键字，创建出来的内容(即:对象)</p></li>
<li><p>特点:存储在堆中的内容，是由Java中的垃圾回收器(GC),统一管理回收</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>方法区:</dt><dd><ul>
<li><p>存放.class文件</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>本地方法区</dt><dd><ul>
<li><p>常量存放在常量池中，而常量池就在方法区中</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>寄存器</p></li>
</ul>
<p>### 方法
- 什么是方法?</p>
<blockquote>
<div><ul class="simple">
<li><p>在程序中把一段代码进行抽取并封装，封装为一个具有独立功能的代码块，这块代码起个名称之后就成为“方法”</p></li>
<li><p>main()就是一个方法</p></li>
<li><p>方法(method)也叫函数(function),在具体实现上是一样的</p></li>
<li><p>public static void main(String[] args),public static是修饰符,void表示没有返回值,main就是方法名,String[] args是参数</p></li>
</ul>
</div></blockquote>
<ul>
<li><p>方法可以传递数据</p></li>
<li><p>方法可以返回结果</p></li>
<li><p>好处:提高了代码的**复用率**</p></li>
<li><dl>
<dt>方法的重载</dt><dd><ul>
<li><p>同样的方法，不同的参数列表(参数个数、参数类型以及参数的顺序)</p></li>
<li><p>参数的传递有基本数据类型和引用数据类型</p></li>
<li><dl>
<dt>当传递的参数是基本数据类型，形参的改变对实参没有任何影响</dt><dd><dl>
<dt>~~~java</dt><dd><dl>
<dt>public static void main(String[] args) {</dt><dd><blockquote>
<div><p>int number = 100;
System.out.println(“调用change方法前：” + number);
change(number);        //实参.
System.out.println(“调用change方法后：” + number);</p>
</div></blockquote>
<p>}
public static void change(int number) {   //形参.</p>
<blockquote>
<div><p>number = 200;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>~~~</p>
</dd>
</dl>
<p>&lt;font color=”red”&gt;上面代码在调用change和调用之后number的数值都是100&lt;/font&gt;</p>
</li>
<li><p>方法中传递的参数类型是引用数据类型时，传递的是地址值(内存中开辟的空间的地址值)，当在方法中对传递的引用类型的参数</p></li>
</ul>
<dl>
<dt>进行相关操作时，会直接影响实参</dt><dd><blockquote>
<div><dl>
<dt>~~~java</dt><dd><dl>
<dt>public static void main(String[] args) {</dt><dd><blockquote>
<div><p>int[] arr = {10, 20, 30};
System.out.println(“调用change方法前：” + arr[1]);
change(arr);
System.out.println(“调用change方法后：” + arr[1]);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public static void change(int[] arr) {</dt><dd><p>arr[1] = 200;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>~~~</p>
</div></blockquote>
<p>调用之前打印的是20，调用之后打印的是200</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p>&gt; 不建议在一个.java文件中书写多个类
&gt; 一个.java中只允许出现一个public class
&gt; .java文件的名称必须和public class类名保持一致</p>
<p>### 类和对象</p>
<ul>
<li><dl class="simple">
<dt>成员变量和局部变量</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>在方法中定义的变量，称为局部变量</dt><dd><ul>
<li><p>局部变量会随着方法的入栈而存在，随着方法的出栈而销毁(存活时间:方法在栈中执行时)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>在类中定义的变量，称为成员变量</dt><dd><ul>
<li><p>随着对象的创建，而存在堆空间，随着对象对的销毁(GC的回收)而消失</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>二者区别</dt><dd><ul>
<li><dl class="simple">
<dt>定义位置不同</dt><dd><ul>
<li><p>成员变量: 定义在类中, 方法外</p></li>
<li><p>局部变量: 定义在方法中, 或者方法声明上</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>在内存中的存储位置不同</dt><dd><ul>
<li><p>成员变量: 存储在堆内存</p></li>
<li><p>局部变量: 存储在栈内存</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>生命周期不同</dt><dd><ul>
<li><p>成员变量: 随着对象的创建而存在, 随着对象的消失而消失</p></li>
<li><p>局部变量: 随着方法的调用而存在, 随着方法的调用完毕而消失</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>初始化值不同</dt><dd><ul>
<li><p>成员变量: 有默认值</p></li>
<li><p>局部变量: 没有默认值, 必须先定义, 再赋值, 然后才能使用</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt><strong>就近原则</strong></dt><dd><ul>
<li><p>当在方法中和方法所属的类中，有相同名称的变量时，在方法中使用变量时，<strong>优先使用局部变量</strong></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>在java语言中，是使用类进行编写java程序</p></li>
<li><p>~~~java
class 类名{</p>
<blockquote>
<div><p>//书写java代码</p>
</div></blockquote>
</li>
<li><p>在类中可以书写的内容有哪些？
- 变量
- 方法</p></li>
<li><p>在java语言中，类除了是用来定义所书写的程序外，类的另一个作用：自定义类型</p></li>
<li><p>当书写完自定义类后，需要对类进行初始化（数据类型  变量=初始化）</p></li>
<li><p>怎么对类进行初始化（初始化的动作，底层：开辟堆内存空间）</p>
<ul>
<li><p>~~~java
类名  对象名 =  new  类名();</p>
<p>类名 ：  数据类型
对象名  ：  变量名
new  ：  告知JVM要开辟堆空间
类名()  ：  告知JVM要开辟空间的大小 （ 类中所书写的所有内容[变量]，进行换算，然后开辟空间 ）</p>
<blockquote>
<div><p>自动调用构造方法</p>
</div></blockquote>
<p>~~~</p>
</li>
</ul>
</li>
</ul>
<p>### 面向对象的三大特征:封装 继承 多态
####封装
什么是封装?
在面向对象中，对于事物描述是使用类进行的(把事物的属性和行为封装到类中)</p>
<p>好处:
- 使用类封装，提高代码的复用性
- 安全性:隐藏了代码的内容 (private)</p>
<ul>
<li><dl>
<dt>private关键字</dt><dd><ul class="simple">
<li><p>用来修饰类中的成员变量和成员方法</p></li>
<li><p>被private修饰的内容只能在本类中使用</p></li>
<li><p>在程序中如果使用private修饰了成员变量后，需要针对该成员变量提供public方法</p></li>
</ul>
<p>虽然把成员变量饰为private，但还是需要对外提供可以访问私有成员变量的接口:public方法
~~~java</p>
<blockquote>
<div><dl>
<dt>public class Student {</dt><dd><p>//属性, 全部用private修饰.
//姓名
private String name;
//年龄
private int age;</p>
<dl class="simple">
<dt>public String getName() {</dt><dd><p>return name;</p>
</dd>
</dl>
<p>}
public void setName(String n) {</p>
<blockquote>
<div><p>name = n;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public int getAge() {</dt><dd><p>return age;</p>
</dd>
</dl>
<p>}
public void setAge(int a) {</p>
<blockquote>
<div><p>age = a;</p>
</div></blockquote>
<p>}</p>
<p>//行为, 也就是成员方法.
public void study() {</p>
<blockquote>
<div><p>System.out.println(“键盘敲烂, 月薪过万!”);</p>
</div></blockquote>
<p>}
public void eat() {</p>
<blockquote>
<div><p>System.out.println(“学习饿了就要吃饭!.”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//测试类
public class StudentTest {</p>
<blockquote>
<div><dl class="simple">
<dt>public static void main(String[] args) {</dt><dd><p>//1. 创建学生对象.
Student s = new Student();
//2. 设置成员变量值.
s.setName(“张三”);
s.setAge(23);
//3. 打印成员变量值.
System.out.println(s.getName() + “…” + s.getAge());
//4. 调用成员方法.
s.study();
s.eat();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>~~~
- 在开发中，通常会把类中所有的成员变量，全部修饰为private，然后提供public 数据类型 getXxx() 、
public void setXxx(数据类型 变量)方法</p>
<blockquote>
<div><ul class="simple">
<li><p>快捷键 Alt+Insert 点击generate下的Getter and Setter快速生成</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</li>
<li><p>this关键字</p></li>
</ul>
<p>是java中的关键字，表示当前类(本类对象)，其实就是**用来区分局部变量和成员变量的**
(前提是存在局部变量和成员变量重名)</p>
<ul class="simple">
<li><dl class="simple">
<dt>super关键字</dt><dd><ul>
<li><p>使用方式上和this很像，super是对父类对象的引用</p></li>
<li><p>super.成员变量名 -&gt; 一定是书写在子类中</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>static</dt><dd><ul>
<li><p>静态方法中不能使用this关键字</p></li>
<li><p>静态方法中只能调用静态方法</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>#### 构造方法
1.用来创建对象
2.用来给类中的成员变量进行赋值</p>
<ul class="simple">
<li><dl class="simple">
<dt>特征</dt><dd><ul>
<li><p>因为没有返回值，所以不需要return</p></li>
<li><p>构造方法名和类名完全一致</p></li>
<li><p>构造方法没有返回值，连void都不需要写</p></li>
<li><p>构造方法通常是在使用new关键字时，由JVM自动加载到栈中执行</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>当一个类中没有书写任何构造方法时，在对类进行编译时，会自动向生成的.class文件中添加一个无参的构造方法(默认构造方法)</p></li>
<li><p>当在一个类中，有上写构造方法时，在对类进行编译时，不会再自动向生成的.class添加一个</p></li>
</ul>
<p>无参的构造方法(默认的),**为了确保会自动编译默认的构造方法(果需要)，必须手动将默认的构造方法进行重载**</p>
<ul>
<li><dl>
<dt>了解构造方法中的隐式三步 [去了解](<a class="reference external" href="https://blog.csdn.net/kingzone_2008/article/details/45015301">https://blog.csdn.net/kingzone_2008/article/details/45015301</a>)</dt><dd><ul>
<li><dl>
<dt>1、调用父类的构造函数(super())</dt><dd><ul class="simple">
<li><p>三种情况:</p></li>
</ul>
<p>1）构造方法体的第一行是this语句，则不会执行隐式三步，
2）构造方法体的第一行是super语句，则调用相应的父类的构造方法，
3）构造方法体的第一行既不是this语句也不是super语句，则隐式调用super()，即其父类的默认构造方法，这也是为什么一个父类通常要提供默认构造方法的原因；</p>
</dd>
</dl>
</li>
<li><p>2、给非静态成员变量赋予显示值</p></li>
<li><p>3、执行构造代码块</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>#### 继承
1.什么是继承?</p>
<blockquote>
<div><p>在一个累的基础上，另一个类继承该类，继承类可以继承前面类中的属性和行为</p>
</div></blockquote>
<p>2.使用extends关键字来实现继承</p>
<dl class="simple">
<dt>3.书写格式:</dt><dd><ul class="simple">
<li><p>至少需要两个类</p></li>
<li><p>需要使用extends关键字</p></li>
<li><p>继承后，继承的类可以使用被继承类中的非私有的成员变量和成员方法</p></li>
</ul>
</dd>
</dl>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a>java
//人类，父类
class person{</p>
<blockquote>
<div><p>String name;
…</p>
</div></blockquote>
<p>}
//学生类，子类
class Student extends Person{
//String name;
int age;
….
}</p>
<p>//Person类有name成员变量，Student类中也有name成员变量，可以省略Student类中
的name成员变量
//子类继承父类就可以拥有父类的一些成员变量，成员方法的访问权限(private不能访问)
<a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a></p>
<ul>
<li><dl class="simple">
<dt>好处</dt><dd><ul class="simple">
<li><p>代码复用</p></li>
<li><p>代码的可维护性</p></li>
<li><p>让类和类之间建立了关系(为多态的前提)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>特点</dt><dd><ul class="simple">
<li><p>只能单一继承(子类只能继承于一个父类)</p></li>
<li><p>支持多层继承(A继承于B,B继承与C)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>构造方法的特点</dt><dd><ul class="simple">
<li><p>子类的每一个构造方法，默认都会先调用父类中默认的构造方法</p></li>
<li><p>当子类中没有默认的构造方法时，子类构造方法在执行时，如没有</p></li>
</ul>
<p>书写super(参数)代码，则报错
- 当子类构造方法中，需要调用父类的有参构造方法时，必须在子类的构造方法中书写super(参数)，并且
<strong>必须书写在第一行</strong></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>在继承中成员方法的特点</dt><dd><ul class="simple">
<li><p>1.在父子类同时具有一模一样的成员方法时，在使用子类对象.成员方法，优先调用子类的成员方法，此即是**就近原则**</p></li>
<li><p>2.如果子类没有，就去父类中找，父类也没有就报错</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl>
<dt>方法的重写(override)</dt><dd><ul class="simple">
<li><dl class="simple">
<dt>为什么要重写</dt><dd><ul>
<li><p>父类的该方法功能不全或者不好用，不能满足实际需求，故重写</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>在子类中</p></li>
<li><p>子类中的方法必须和父类中的方法**一模一样**(名称、参数、返回值)</p></li>
<li><p>父类的private方法不能重写</p></li>
<li><p>static静态方法不能被重写，静态方法只能被继承，如果子类中定义了同名同形式的静态方法，它对父类方法只能起到</p></li>
</ul>
<p>隐藏的作用，调用的时候用谁的引用，就调用谁的版本
- 父类中的方法使用public修饰时，子类中要对其重写，必须也用public
- 子类的中方法重写权限不能更低
- 白话:保证一模一样就啥事没有</p>
</dd>
</dl>
</li>
</ul>
<p>### 抽象类
- 抽象方法:当方法体中不清楚应该怎么样写具体的功能时，就可以不写具体的功能(省略方法体代码)</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>当方法省略体内具体的功能时，就描述不清楚</dt><dd><ul>
<li><p>针对描述不清楚的内容，在java中统一使用:抽象</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>仅声明方法，没有具体的方法体功能代码，这个方法称为:抽象方法</dt><dd><ul>
<li><p>抽象方法:public <strong>abstract</strong> void method(){…}</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>抽象类:当对事物描述不清楚时，就用抽象类</dt><dd><ul>
<li><p>抽象类通常是父类</p></li>
<li><p>抽象方法只能书写在抽象类中</p></li>
<li><p>抽象类不能实例化(无法实例化)</p></li>
<li><dl class="simple">
<dt>抽象类通常必须有一个子类</dt><dd><ul>
<li><p>利用多态，实现抽象类的实例化: 抽象类 父引用= new 子类;</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>抽象类的意义:在于“被继承”,抽象类被其子类“抽象”出了公共的部分，通常也定义了子类所必须具体实现的抽象方法。</dt><dd><ul>
<li><p>若一个类继承自抽象类必须重写抽象方法，否则自己也应该变成抽象类</p></li>
<li><p>因此，抽象类对子类具有强制性和规范性，这叫做模板设计模式</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 接口
- 定义类的关键字关键字class ，定义接口的关键字是interface</p>
<blockquote>
<div><p>继承类的关键字是extends，而实现接口的关键字是implements
当多个类型之间具有相同的行为能力的时候，java中就可以通过接口来进行类型之间的联系，通过接口可以解决单继承所带来的的一些无法共享的问题</p>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>语法格式</dt><dd><p>~~~java</p>
</dd>
<dt>修饰符 interface 接口名称 [extends 父接口1,父接口…]{</dt><dd><p>零个到多个常量的定义
零个到多个抽象方法的定义
零个到多个默认方法的定义
零个到多个静态方法的定义</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>注意:</dt><dd><dl class="simple">
<dt>&gt; 1.接口可以实现多继承，也就是说一个接口可同时继承多个父接口</dt><dd><p>2.实现接口的类如果不能实现所有接口中待重写的方法，则必须设置为抽象类
3.一个类可以继承自一个父类，可以同时实现多个接口
4.成员变量要用 public static final修饰，也就是常量
5.接口中所有成员方法必须有public abstract共同修饰，也就是抽象方法</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p>### static关键字
&gt; 通常情况下成员变量都隶属于对象层级，每个对象都拥有独立的内存空间来记录自己独有的成员变量，当所有的
&gt; 对象的成员变量的值都完全一样时，若每个对象单独记录则会造成内存空间的浪费，此时应该将该成员变量由对象层级提升至
&gt; 类层级，在内存空间中只保留一份且被所有的对象所共享，为了实现该效果，故使用static关键字来修饰，表示静态的含义。
&gt; static关键字可以修饰成员变量和成员方法表示隶属于类层级，推荐使用”类名.”的方式访问</p>
<ul class="simple">
<li><dl class="simple">
<dt>使用方式</dt><dd><p>1.对于非静态的成员方法来说，既可以访问非静态的成员同时也可以访问静态的成员；(成员:成员变量+成员方法)
2.对于**静态的成员**方法来说，<strong>只能访问静态的成员</strong>，不能访问非静态的成员；(如果非要调用非静态方法，必须使用”对象.非静态方法”的方式访问，对于非静态变量也是如此)
(执行静态方法的时候**可能还没有创建对象**，非静态成员隶属于对象层级)
3.只有被所有对象共享的内容才能被static修饰，不能随便加</p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>静态成员</dt><dd><ul>
<li><p>存放在JVM的方法区内</p></li>
<li><p>使用“类名.”访问</p></li>
<li><p>随着类的加载而存在，早于对象的创建</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>非静态成员</dt><dd><ul>
<li><p>存放在JVM的堆内存中</p></li>
<li><p>通过“对象.”访问</p></li>
<li><p>随着对象的创建而存在，晚于对象的创建</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>注意事项:</dt><dd><ul>
<li><p>静态方法中是无法使用this和super的</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 对象创建的过程
#### 单个对象创建的过程
1.将xxx.class文件中的相关类信息读取到内存空间的方法区，这个过程叫做类的加载
2.当程序开始运行时找main()方法去执行方法体重的语句，使用new来创建对象
3.若没有指定初始值，采用默认的初始化，否则采用指定的数值来初始化
4.可以通过构造块来进行更改成员变量的数值
5.执行构造方法体中的语句，可以进行再次的修改成员变量的数值
6.此时对象创建完毕，继续执行后续的语句</p>
<p>TestSuperObject类中的静态语句块
TestSuperObject类中的构造块
TestSuperObject()的方法体</p>
<p>#### 子类对象创建的过程
1.先加载父类再去加载子类，先执行父类的静态语句块，再执行子类的静态语句块；
2.执行父类的构造块，再执行父类的构造方法体，此时父类部分构造完毕
3.执行子类的构造块，再执行子类的构造方法体，此时子类对象构造完毕</p>
<p>TestSuperObject类中的静态语句块
TestSubObject类中的静态语句块
TestSuperObject类中的构造块
TestSuperObject()的方法体
TestSubObject类中的构造块
TestSubObject()的方法体</p>
<p>总结: <strong>静态块&gt;main()&gt;构造块&gt;构造方法</strong></p>
<p>#### 多态
- 三个条件</p>
<blockquote>
<div><ul class="simple">
<li><p>1.要有继承</p></li>
<li><p>2.要有重写</p></li>
<li><p>3.父类引用指向子类对象</p></li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>引用类型之间的转换</dt><dd><ul class="simple">
<li><p>1.引用类型转换必须发生在父子类之间，分为自动类型转换(向上转型)和强制类型转换(向下转型)</p></li>
<li><p>2.向上转型(子类类型向父类转换)</p></li>
</ul>
<p>如:Person p = new Student();
&gt; 注意: 父类中的静态方法无法被子类重写，所以需要向上转型之后才能调用父类原有的静态方法
- 3.向下转型(父类类型向子类类型转换)
子类引用父类实例，必须进行强制类型转换，可以调用子类特有的方法，必须满足转型的条件才能。
使用instanceof运算符进行判断
父类的静态方法只能被子类继承而无法被子类重写
- 4.当没有父子类关系时发生强制类型转换编译报错，当拥有父子类关系时编译通过
- 为了避免上述错误的发生，通常只要进行强制类型转换就需要进行判断，格式:
if(引用变量名 instanceof 数据类型){}</p>
</dd>
</dl>
</li>
<li><p>多态的意义</p>
<blockquote>
<div><ul class="simple">
<li><p>多态的意义在于:可以屏蔽不同子类的差异性编写通用的代码，从而产生不同的效果</p></li>
</ul>
</div></blockquote>
</li>
</ul>
<p>~~~java
//父类
abstract class Person{</p>
<blockquote>
<div><p>private String name;
private int age;</p>
<p>//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
//抽象方法： 只定义没有方法体
public abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class Student extends Person{</dt><dd><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校区食堂吃饭…”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
class Teacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校外吃饭…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<blockquote>
<div><dl>
<dt>class Test{</dt><dd><dl>
<dt>public static void main(String[] args){</dt><dd><p>//创建学生对象
Student stu = new Student();</p>
<p>method1( stu  , “zs” , 20  ,   …..)</p>
<p>//创建老师对象
Teacher tea = new Teacher();</p>
<p>method2(  tea ,”ls” ,33 , …… )</p>
</dd>
</dl>
<p>}</p>
<p>//在书写程序时：当发现有重复的代码，建议都进行抽取封装：方法、类  （复用性）</p>
<blockquote>
<div><dl class="simple">
<dt>public static void method1( Student stu, String name , int age , … ){</dt><dd><p>stu.setName( name  );//因为Student继承了Person，可以使用父类中的非私有成员
stu.setAge(  age  );
….
stu.eat();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public static void metho2 ( Teacher  tea , String name , int age , …  ){</dt><dd><p>tea.setName(  name   );
tea.setAge(  age  );
….
tea.eat();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>//添加就业班</p>
<p>//观察以上两个方法中的代码：除了对象名不同，其它都一样   (99%都是重复代码)
针对代码，再次精进：</p>
<blockquote>
<div><p>public void method(  ?   , String name , int age , …){</p>
<blockquote>
<div><p>?.setName(  name   );
?.setAge(  age  );</p>
<p>?.eat();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>? 有两个类型：  Student 、        Teacher
Student类型和Teacher类型有什么相同？
继承的父类是同一个</p>
<p>java语言提供了一种方案：多态
多态的使用:
1、要有继承关系
2、子类要重写父类中的方法
3、 父类的引用指向子类对象</p>
<blockquote>
<div><p>父类  父引用  =  new  子类();</p>
</div></blockquote>
<p>Person p1 = new Student();
p1.setName(…)
p1.eat()//调用的是对象中的eat方法</p>
<p>Person p2 = new Teacher();
p2.setName(….)
p2.eat();</p>
<blockquote>
<div><p>public static void method(  Person p  ,  String name , int age , …  ){</p>
<blockquote>
<div><p>p.setName(  name   );
p.setAge(  age  );</p>
<p>p.eat();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>Student stu = new Student();
Person p = stu ; //多态</p>
<p>method( stu ,”ls” , 20 ,….);</p>
<dl class="simple">
<dt>Teacher tea = new Teacher();</dt><dd><p>method( tea   );</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>~~~</p>
<p>~~~java
//父类
abstract class Person{</p>
<blockquote>
<div><p>private String name;
private int age;</p>
<p>//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
//抽象方法： 只定义没有方法体
public abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class Student extends Person{</dt><dd><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校区食堂吃饭…”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
class Teacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校外吃饭…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>//需求升学：老师需要划分为基础班老师、就业班老师
//父类
abstract class Person{</p>
<blockquote>
<div><p>private String name;
private int age;</p>
<p>//通常父类中的方法无法明确具体的功能代码时，只需要针对方法进行声明（只定义没有方法体）
//抽象方法： 只定义没有方法体
public abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class Student extends Person{</dt><dd><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校区食堂吃饭…”);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//基础班老师
class BasicTeacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“吃外卖…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
//就业班老师
class WorkTeacher extends Person{</p>
<blockquote>
<div><p>//子类在继承了抽象类后，必须重写抽象方法（java语法规定）
public void eat(){</p>
<blockquote>
<div><p>System.out.println(“去校外吃饭…”);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<blockquote>
<div><dl>
<dt>class Test{</dt><dd><dl>
<dt>public static void main(String[] args){</dt><dd><p>//创建学生对象
Student stu = new Student();</p>
<p>//创建基础老师对象
BasicTeacher tea = new BasicTeacher();</p>
<p>//创建就业班老师对象
WorkTeacher tea2 = new WorkTeacher();</p>
<p>method(  stu , “zs” , 20  )
method(  tea , “ls” , 33  )</p>
<p>method(  tea2  , “ja”  30  )</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public static void method(  Person  p ,  String name, int age ){</dt><dd><blockquote>
<div><p>p.setName( name )
p.setAge(age)
…</p>
<p>p.eat();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>~~~</p>
<p>&gt; 在使用多态时，存在 一个问题：父引用无法使用子类中特有的成员
&gt; 解决方案： 使用向下转型 （强制类型转换）
&gt;
&gt; 格式：子类  子类对象 = (子类) 父引用
&gt;
&gt; 当在进行强制类型转换时，如果父引用指向的对象类型 和 要转换的类型不匹配，就会发生：错误
&gt;
&gt; 父引用指向的对象类型 ：  Person p = new Student();  //类型：Student
&gt; 要转换的类型：  Teacher
&gt; 错误代码：  Teacher tea  = (Teacher ) p;//类型转换错误
&gt;
&gt; 通常在进行向下转型时，会先进行判断：
&gt;
&gt; if( p  instanceo  Teacher){
&gt;
&gt;   Teacher tea  = (Teacher ) p;
&gt;
&gt; }
&gt;
&gt; 父引用  instanceof  子类类型    ：  判断父引用指向的对象类型 是否为 子类类型</p>
<p>​
### 包
- 注意事项:</p>
<blockquote>
<div><ul class="simple">
<li><p>package必须书写在程序的第一行</p></li>
<li><p>一个.java文件中只允许写一个package</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>命名规则</dt><dd><ul>
<li><p>全部小写字符</p></li>
<li><p>包名通常是域名倒着写(企业标准)</p></li>
<li><p>通常创建报名有多个包，包之间用.连接</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>导包</dt><dd><ul>
<li><p>package com.xxxx 自己的包 //本类归属的包</p></li>
<li><p>import java.util.Scanner //导包，别人写好的包</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 访问修饰符
1.public
2.private
3.默认
4.protected</p>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a>java
public class Student extends Person{</p>
<blockquote>
<div><p>Protected String name;//受保护的，子类专用</p>
</div></blockquote>
<div class="section" id="id17">
<h1><span class="section-number">4. </span>}<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><dl class="simple">
<dt>概览</dt><dd><p>访问控制            访问权限          本类            本包中的其他类         子类          其他包中的其他类</p>
</dd>
</dl>
</li>
</ul>
<blockquote>
<div><p>默认方式          默认的           1                  1
private         私有的            1</p>
</div></blockquote>
<p>​
​
​</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Java_Maven.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="IO%E6%B5%81.html" class="btn btn-neutral float-left" title="&lt;no title&gt;" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020-2020, roohom

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>