

<!DOCTYPE html>
<html class="writer-html5" lang="zh-CN" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>2. } &mdash; Code-Cookbook 0.1 文档</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="Hive%20SQL50%E9%A2%98%E8%AE%B0%E5%BD%95.html" />
    <link rel="prev" title="&lt;no title&gt;" href="Closure%26Currying.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home" alt="Documentation Home"> Code-Cookbook
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">大数据</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata/index.html">Bigdata</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Bigdata%20Tools/index.html">Bigdata Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">博客</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Blogs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="Annotation.html">1. }</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">2. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id14">3. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%20Cookbook.html">4. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html">5. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="Java%E4%B8%ADSocket%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E8%87%B3%E6%9C%8D%E5%8A%A1%E7%AB%AF.html#id6">6. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html">7. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B%E9%97%AE%E9%A2%98.html#id16">8. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html">9. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id2">10. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id3">11. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id4">12. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id5">13. }</a></li>
<li class="toctree-l2"><a class="reference internal" href="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A2%B3%E7%90%86.html#id6">14. }</a></li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">大数据辅助工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Auxiliary%20tools/index.html">Auxiliary tools</a></li>
</ul>
<p class="caption"><span class="caption-text">SQL相关</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../SQL/index.html">SQL</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Code-Cookbook</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="index.html">Blogs</a> &raquo;</li>
        
      <li><span class="section-number">2. </span>}</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Blogs/Collection.md.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <p># 集合</p>
<p>## 内部类
概念:在一个类中定义另一个类</p>
<ul>
<li><dl>
<dt>两种内部类</dt><dd><ul class="simple">
<li><p>成员内部类</p></li>
</ul>
<dl>
<dt>书写的位置和成员变量、成员方法在同一个位置(方法外)</dt><dd><p>~~~java
public class Person{</p>
<blockquote>
<div><p>//成员内部类
public class InnerClass{</p>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<ul class="simple">
<li><dl class="simple">
<dt>局部内部类</dt><dd><ul>
<li><dl class="simple">
<dt>局部内部类</dt><dd><ul>
<li><p>书写在成员方法内</p></li>
<li><p>不能使用访问修饰符</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>### 匿名内部类
匿名内部类:匿名对象+子类
- 匿名对象</p>
<blockquote>
<div><ul class="simple">
<li><dl class="simple">
<dt>Student stu = new Student();创建一个Student对象</dt><dd><ul>
<li><p>访问方法:stu.method()</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>匿名对象格式:</dt><dd><ul>
<li><p>书写格式:new Student()</p></li>
<li><p>访问内部成员方法 new Student().method()</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>作用:通常用于作实参传递</p></li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>子类</dt><dd><ul>
<li><p>~~~java
//父类
abstract class Person{</p>
<blockquote>
<div><p>abstract void eat();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>class Student exdents Person{</dt><dd><p>public void eat(){
}</p>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>匿名内部类+子类</p></li>
</ul>
<p>一个继承了类或者接口的子类对象
~~~java
new Student
{</p>
<blockquote>
<div><p>//重写方法
public void eat(){
}</p>
</div></blockquote>
<div class="section" id="id1">
<h1><span class="section-number">2. </span>}<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<ul class="simple">
<li><dl class="simple">
<dt>使用</dt><dd><ul>
<li><p>1.当抽象类或接口中没有过多方法使用也比较少，可以考虑使用匿名内部类的方式</p></li>
<li><p>2.匿名内部类可以作为方法的实参进行传递</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>## 集合
- 概念:</p>
<blockquote>
<div><ul class="simple">
<li><p>集合是用来存储多个同类型的数据的容器，它的长度是可以变化的</p></li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>集合的体系结构</dt><dd><dl>
<dt>~~~</dt><dd><p>Collection接口:
<a href="#id2"><span class="problematic" id="id3">|</span></a>— List接口:</p>
<blockquote>
<div><p><a href="#id4"><span class="problematic" id="id5">|</span></a>—ArrayListL类:
<a href="#id6"><span class="problematic" id="id7">|</span></a>—LinkedList类:</p>
</div></blockquote>
<dl class="simple">
<dt><a href="#id8"><span class="problematic" id="id9">|</span></a>— Set接口:</dt><dd><p><a href="#id10"><span class="problematic" id="id11">|</span></a>—Hash类:
<a href="#id12"><span class="problematic" id="id13">|</span></a>—TreeSet类:</p>
</dd>
</dl>
</dd>
</dl>
<p>~~~</p>
</dd>
</dl>
</li>
</ul>
<p>&gt; 归属于Java.util</p>
<ul class="simple">
<li><dl class="simple">
<dt>Collection是一个接口，属于java集合体系中顶层的父接口，该接口下有两大体系:List、Set</dt><dd><ul>
<li><p>List特点:有序、可重复</p></li>
<li><p>Set特点:无序、唯一</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>使用方式</dt><dd><ul>
<li><p>属于接口，无法实例化，需要借助子类,通过多态的方式创建子类对象</p></li>
<li><p>collection coll = new ArrayList();</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>常用方法</dt><dd><ul>
<li><p>添加:public boolean add(Object obj);</p></li>
<li><p>删除 public boolean remove(Object obj);</p></li>
<li><p>修改 在遍历的过程中针对某个元素进行修改</p></li>
<li><p>查询 需要借助迭代器进行遍历查询</p></li>
<li><p>获取元素个数 public int size();</p></li>
<li><p>是否包含某个元素 public boolean contains(Object obj);</p></li>
<li><p>清空所有元素 public void clear();</p></li>
<li><p>判断是否为空 public boolean isEmpty();</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>&gt; 集合内装的元素都经过了类型提升为Object(比如整形经过了自动装箱)</p>
<p>### 泛型:约束的类型
常用于创建集合时使用，用来约束集合中可以存储的元素的类型</p>
<p>### 集合的遍历
- 集合没有类似数组一样的索引，无法利用索引进行遍历，需要借助迭代器</p>
<blockquote>
<div><ul class="simple">
<li><p>Iterator it = Collection.iterator();</p></li>
<li><dl class="simple">
<dt>常用方法:</dt><dd><ul>
<li><p>public boolean hasNext()      //判断迭代器中是否还有下一个元素.</p></li>
<li><p>public E next()                       //获取迭代器中的下一个元素.</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<ul>
<li><dl>
<dt>集合遍历的大致过程</dt><dd><ul class="simple">
<li><p>1.创建集合对象.</p></li>
<li><p>2.创建元素对象.</p></li>
<li><p>3.把元素添加到集合中.</p></li>
<li><dl class="simple">
<dt>4.遍历集合</dt><dd><ul>
<li><p>1.根据集合对象获取其对应的迭代器对象.
通过Collection#iterator()方法实现.</p></li>
<li><p>2.判断迭代器中是否有下一个元素.
通过Iterator#hasNext()方法实现.</p></li>
<li><p>3.如果有, 就获取该元素.
通过Iterator#next()方法实现.</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>案例:</p></li>
</ul>
<dl>
<dt>~~~java</dt><dd><p>//案例: 演示Collection集合存储自定义对象, 并遍历
public class Demo {</p>
<blockquote>
<div><dl>
<dt>public static void main(String[] args) {</dt><dd><p>//1. 创建集合对象.
Collection&lt;Student&gt; coll = new ArrayList&lt;&gt;();
//2. 创建元素对象.
Student s1 = new Student(“刘亦菲”, 33);
Student s2 = new Student(“赵丽颖”, 31);
Student s3 = new Student(“高圆圆”, 35);
//Student s4 = new Student(“丹丹”, 18);
//3. 把元素对象添加到集合对象中.
coll.add(s1);
coll.add(s2);
coll.add(s3);
//coll.add(s4);
//4. 遍历集合.
//4.1 根据集合对象获取其对应的迭代器对象. Collection#iterator();
Iterator&lt;Student&gt; it = coll.iterator();
//4.2 判断迭代器中是否有下一个元素. Iterator#hasNext();
while (it.hasNext()) {</p>
<blockquote>
<div><p>//4.3 有就获取. Iterator#next();
Student stu = it.next();
System.out.println(stu);</p>
<p>//不能写成如下的形式, 因为next()方法调用一次, 就会获取一个值.
//下边这个代码就属于: 判断一次, 获取两个值.
//System.out.println(it.next().getName() + “…” + it.next().getAge());</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>~~~</p>
</dd>
</dl>
</li>
</ul>
<p>### List集合
- 特点:</p>
<blockquote>
<div><ul class="simple">
<li><p>1.存取元素有序。存储元素的顺序和取出元素的顺序一致</p></li>
<li><p>2.list集合允许存储重复元素</p></li>
<li><p>3.list集合中有索引，可以利用索引精确访问集合中的每一个元素</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>创建:</dt><dd><ul>
<li><p>没有构造方法</p></li>
<li><p>List是一个接口，无法实例化，需要借助子类</p></li>
<li><p>List list = new ArrayList();</p></li>
<li><p>List继承于Collection,父接口的相关功能，list集合也可以使用</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>常用方法(特有方法):</dt><dd><ul>
<li><p>添加 void add(int index, Object obj)</p></li>
<li><p>修改 Object set(int index, Object obj) //指定索引位置上的元素修改为Obj，并返回修改之前的元素</p></li>
<li><dl class="simple">
<dt>删除</dt><dd><ul>
<li><p>boolean remove(Object obj) 删除指定对象</p></li>
<li><p>Object remove(int index) 删除指定位置元素并返回旧元素</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>查询</dt><dd><ul>
<li><p>Object get(int index) 查询到元素并返回</p></li>
<li><p>int indexOf(Object obj)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>遍历</dt><dd><ul>
<li><p>iterator迭代器(见ListDemo4.java)</p></li>
<li><p>ListIterator迭代器(专有)</p></li>
<li><dl class="simple">
<dt>四种方式:</dt><dd><ul>
<li><dl class="simple">
<dt>1.Iterator迭代器</dt><dd><ul>
<li><p>不适合遍历的同时增删</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>2.ListIterator迭代器</p></li>
<li><p>3.for循环</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>迭代器</dt><dd><ul>
<li><dl class="simple">
<dt>普通迭代器的弊端</dt><dd><ul>
<li><p>在迭代遍历时，如果向list集合中**添加**新元素或**删除**元素，迭代器会引发异常:ConcurrentModificationException</p></li>
<li><dl class="simple">
<dt>解决办法:</dt><dd><ul>
<li><p>使用专用迭代器:ListIterator (ListIterator listIt = list.ListIterator())</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>增强for循环的底层是迭代器</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>#### AarrayList类
- 底层使用可变**数组**
- 特点</p>
<blockquote>
<div><ul class="simple">
<li><p>存取有序，有索引</p></li>
<li><p>可以存储重复元素</p></li>
<li><p>查询和修改效率比较高</p></li>
<li><p>添加和删除元素效率比较低</p></li>
</ul>
</div></blockquote>
<p>#### LinkedList类
- 底层使用**链表**
- 在创建LinkedList时所指定的索引，可以指定位置，但是在查询的时候用不上
- 特点</p>
<blockquote>
<div><ul class="simple">
<li><p>存取有序</p></li>
<li><p>可以存储重复元素</p></li>
<li><p>可以存储null</p></li>
<li><p>有角标，但是底层是链表结构用不上</p></li>
<li><p>添加和删除元素效率高</p></li>
<li><dl class="simple">
<dt>查询较慢，修改元素值较慢</dt><dd><ul>
<li><p>链表特性:有头有尾</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>特有方法(针对链表的头和尾设计的):</dt><dd><ul>
<li><dl class="simple">
<dt>添加:</dt><dd><ul>
<li><p>addFirst(Object obj)</p></li>
<li><p>addLast(Object obj)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>删除</dt><dd><ul>
<li><p>removeFirst()</p></li>
<li><p>removeLast()</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>获取</dt><dd><ul>
<li><p>getFirst()</p></li>
<li><p>getLast()</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>## 增强For循环
增强for循环是用来遍历的，针数组和集合的遍历
- 弊端</p>
<blockquote>
<div><ul class="simple">
<li><p>只能用来遍历</p></li>
<li><p>增强for的底层其实是通过迭代器(Iterator)实现的</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>格式:</p></li>
</ul>
<p>~~~java
int[] arr = {11,22,33,44,55};</p>
<dl class="simple">
<dt>for(元素类型 变量名<span class="classifier">array){</span></dt><dd><p>//直接使用变量名就可以获取到array中的每一个元素</p>
</dd>
</dl>
<p>}</p>
<p>//集合
List list = new ArrayList();
for(元素类型 元素名: list){</p>
<blockquote>
<div><p>//打印</p>
</div></blockquote>
</div>
<div class="section" id="id14">
<h1><span class="section-number">3. </span>}<a class="headerlink" href="#id14" title="永久链接至标题">¶</a></h1>
<p>&gt; 在循环过程中不能向集合中添加元素或者删除元素</p>
<p>## 集合的遍历
- 1.普通迭代器</p>
<blockquote>
<div><ul class="simple">
<li><p>iterator it = 集合对象.iterator()</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>2.专用迭代器</dt><dd><ul>
<li><p>只适用于List</p></li>
<li><p>ListIterator li = 集合对象.listIterator()</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>3.普通for循环</p></li>
<li><p>4.增强for循环</p></li>
</ul>
<p><strong>如果要对集合元素进行删除修改应该使用for循环和专用迭代器</strong></p>
<p>## 数据结构
# 简单(常用)数据结构
- 栈
- 队列
- 数组(可变数组)
- 链表
## 栈
- 特点:FILO,先进后出</p>
<p>## 队列
- 特点:FIFO,先进先出</p>
<p>## 可变数组
创建新数组，将原数组中元素选择性拷贝到新数组中
- 特点</p>
<blockquote>
<div><ul class="simple">
<li><p>有索引</p></li>
<li><p>查询效率高</p></li>
</ul>
</div></blockquote>
<p>## 链表
内存中的存储节点，每个节点通过地址值链接在一起
- 特点</p>
<blockquote>
<div><ul class="simple">
<li><p>查找元素时，从链表的头部开始遍历查找</p></li>
<li><p>无索引</p></li>
<li><p>查询效率低</p></li>
<li><p>添加删除元素的效率高</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><p>单链表</p></li>
<li><p>双链表</p></li>
</ul>
<p>## Set集合
- 特点</p>
<blockquote>
<div><ul class="simple">
<li><p>存取无序，唯一</p></li>
<li><p>不能存储重复元素</p></li>
<li><p>是一个接口，无法实例化，需要借助子类</p></li>
<li><p>无索引，不能通过for循环遍历</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>子类:HashSet和TreeSet</dt><dd><ul>
<li><dl class="simple">
<dt>HashSet底层使用哈希表结构</dt><dd><ul>
<li><dl class="simple">
<dt>哈希表结构在存储元素时的过程</dt><dd><ul>
<li><dl class="simple">
<dt>1.拿出存储的元素，结合哈希算法，计算出元素的存储位置</dt><dd><ul>
<li><p>借助了HashCode()方法</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2.把存储的元素存放到计算出来的位置上</dt><dd><ul>
<li><dl class="simple">
<dt>判断在该位置上是否已经存在元素</dt><dd><ul>
<li><p>没有:直接在该位置存储</p></li>
<li><dl class="simple">
<dt>有:比较两个元素是否相同(要存储的元素、已存在的元素)</dt><dd><ul>
<li><p>相同:意味着元素一样，不用存储</p></li>
<li><p>不同:拉链法(拿计算出来的位置，再次结合哈希算法重新计算存储的位置)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><p>TreeSet底层使用树结构</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>&gt; 在使用HashSet集合存储自定义对象时，如果希望所存储的自定义对象属性的值不能重复时，需要对HashCode()和equals()方法进行重写
- 遍历</p>
<blockquote>
<div><ul class="simple">
<li><p>迭代器</p></li>
<li><p>增强for</p></li>
<li><p>toArray()</p></li>
</ul>
</div></blockquote>
<p>## 可变参数
定义不同的参数的方法，通过重载来实现，但是当参数的个数越来越多时，重载就不好使了，就需要使用可变参数
- 格式:</p>
<blockquote>
<div><ul class="simple">
<li><p>修饰符 返回值类型 方法名(数值类型… 变量名)</p></li>
</ul>
</div></blockquote>
<ul class="simple">
<li><dl class="simple">
<dt>要求</dt><dd><ul>
<li><p>可变参数必须书写在方法参数声明的最后一个参数位置上</p></li>
<li><p>在方法参数声明时，只能存在一个可变参数(不考虑参数类型)</p></li>
<li><p>当方法中需要传递其他参数时，需要将这些参数书写在可变参数之前</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>## Map集合
是一个接口，不能实例化，需要借助子类
- 特点</p>
<blockquote>
<div><ul class="simple">
<li><p>底层使用了两个单列集合</p></li>
<li><p>存储两个元素:一次存储一对元素(键值对)</p></li>
<li><p>存储的Key元素不能重复(底层使用使用Set集合来存储键)</p></li>
</ul>
</div></blockquote>
<p>~~~
<a href="#id15"><span class="problematic" id="id16">|</span></a>–HashMap类
<a href="#id17"><span class="problematic" id="id18">|</span></a>–TreeMap类
~~~</p>
<ul class="simple">
<li><dl class="simple">
<dt>常用方法:</dt><dd><ul>
<li><dl class="simple">
<dt>添加:</dt><dd><ul>
<li><dl class="simple">
<dt>public V put(Object key,Object value)</dt><dd><ul>
<li><p>一次性向集合中添加键值对这一对元素，并返回value</p></li>
<li><dl class="simple">
<dt>底层实现:现在Map集合中通过key来判断是否存在的key元素</dt><dd><ul>
<li><p>有:就直接针对当前的key，来修改value(新的覆盖旧的)，返回旧的value</p></li>
<li><p>没有，直接添加</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>如果Map是空集合，第一次使用put方法，返回的是null，因此可以通过判断返回的是不是null来判断是不是第一次天剑</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>修改:</dt><dd><ul>
<li><p>public V put(Object key,Object value)</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>删除:</dt><dd><ul>
<li><p>public V remove(Object key) //根据指定的键删除集合中相应的一对元素，返回被删除的value</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>查询:public V get(Object key) //根据指定的key元素，获取集合中匹配的value元素</p></li>
<li><dl class="simple">
<dt>判断:</dt><dd><ul>
<li><p>boolean containsKey(Object key)</p></li>
<li><p>boolean containsValue(Object value)</p></li>
<li><p>boolean isEmpty() 判断是否为空</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>遍历</dt><dd><ul>
<li><p>Map集合本身无法遍历，Map集合中没有迭代器</p></li>
<li><dl class="simple">
<dt>Map集合的遍历:</dt><dd><ul>
<li><dl class="simple">
<dt>1.使用存储Key元素的Set集合，实现遍历</dt><dd><ul>
<li><dl class="simple">
<dt>1.先获取到存储所有Key元素的Set集合</dt><dd><ul>
<li><p>Map集合对象中的KeySet()方法</p></li>
</ul>
</dd>
</dl>
</li>
<li><p>2.遍历Set集合(迭代器，增强for)</p></li>
<li><p>3.遍历过程中获取每一个key元素</p></li>
<li><p>4.利用Map集合中的get(Object key),实现通过key获取value</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>2.向Map集合中存储的一对键值对对象类型是:Map.Entry类型</dt><dd><ul>
<li><p>1.利用Map集合中的方法，获取集合中所有的Map.Entry</p></li>
<li><p>2.遍历所有的Map.Entry</p></li>
<li><dl class="simple">
<dt>3.利用Map.Entry对象中的方法，分别获取:Key,Value</dt><dd><ul>
<li><dl class="simple">
<dt>EntrySet()</dt><dd><ul>
<li><p>获取所有的键值对对象集合(Set集合&lt;Map.Entry&gt;)</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
<p>## 小结
~~~
<a href="#id19"><span class="problematic" id="id20">|</span></a>—Collection集合(接口):单列集合的顶层父接口</p>
<blockquote>
<div><dl class="simple">
<dt><a href="#id21"><span class="problematic" id="id22">|</span></a>—List集合(接口):存取有序、有索引、元素可重复</dt><dd><dl class="simple">
<dt><a href="#id23"><span class="problematic" id="id24">|</span></a>—ArrayList集合(类):底层使用数组，查询修改比较高快</dt><dd><p><a href="#id25"><span class="problematic" id="id26">|</span></a>— 常用方法:add remove set get</p>
</dd>
<dt><a href="#id27"><span class="problematic" id="id28">|</span></a>—LinkList集合(类):底层使用链表，删除添加比较快</dt><dd><p><a href="#id29"><span class="problematic" id="id30">|</span></a>—常用方法:addFirst addLast removeFirst removeLast getFirst getLast</p>
</dd>
</dl>
</dd>
<dt><a href="#id31"><span class="problematic" id="id32">|</span></a>—Set集合(接口):存取无序，没有索引，元素唯一</dt><dd><p><a href="#id33"><span class="problematic" id="id34">|</span></a>—常用方法:全部来自于Collection
<a href="#id35"><span class="problematic" id="id36">|</span></a>—HashSet集合(类):底层使用哈希表
<a href="#id37"><span class="problematic" id="id38">|</span></a>—TreeSet集合(类):底层使用树(二叉树)结构
<a href="#id39"><span class="problematic" id="id40">|</span></a>—LinkedHashSet(类):底层使用哈希表+链表结构。特点，有序存取</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt><a href="#id41"><span class="problematic" id="id42">|</span></a>—Map集合(接口):双列集合的顶层父接口</dt><dd><dl class="simple">
<dt><a href="#id43"><span class="problematic" id="id44">|</span></a>—常用方法:put remove get</dt><dd><p>Set KeySet() 获取双列集合中用来存储所有的Key元素的单列集合
Set&lt;Map.Entry&gt; entrySet</p>
</dd>
</dl>
<p><a href="#id45"><span class="problematic" id="id46">|</span></a>—HashMap集合(类):底层使用哈希表
<a href="#id47"><span class="problematic" id="id48">|</span></a>—TreeMap集合(类):底层使用树结构</p>
</dd>
</dl>
<p>~~~
&gt; 当拿捏不定时，选择List集合</p>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="Hive%20SQL50%E9%A2%98%E8%AE%B0%E5%BD%95.html" class="btn btn-neutral float-right" title="&lt;no title&gt;" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="Closure%26Currying.html" class="btn btn-neutral float-left" title="&lt;no title&gt;" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; 版权所有 2020-2020, roohom

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>